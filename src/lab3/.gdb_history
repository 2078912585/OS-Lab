p/x swapper_pg_dir
p/x _stext
p/x _ekernel
quit
target remote:1234
b head.S:21
b head.S:19
b *0x80200018
c
l
quit
target remote:1234
b head.S:16
b *0x8020000c
c
si
si
si
si
si
si
si
si
si
si
si
si
si
si
si
p/x $satp
si
si
si
si
p/x _start
b reloacate
b relocate
b set_vm_final
b setup_vm_final
b head.S:22
c
si
si
s
c
quit
target remote:1234
d b
d breakpoints
info setup_vm
info f setup_vm
info funcation setup_vm
info funcations setup_vm
info functions setup_vm
b head.S:59
b *0x8020008c
c
si
si
si
li
si
b head.S.35b head.S:35
b head.S:35
c
p/x $satp
info address _stext
quit
target remote:1234
info b
b head.S:59
b *0x8020008c
c
s
ci
si
si
si
si
b head.S:21
c
info $stap
info $satp
p/x $satp
info address _stext
info address _etext
info address _srodata
info address _erodata
define find_pte
  # 参数：$arg0 = 要查询的虚拟地址（比如 .text 的起始地址）
  set $vaddr = $arg0
  # 从 satp 提取页表物理基址（PPN → 物理地址）
  set $root_ppn = $satp & 0x00007FFFFFFFFFFF
  set $root_pte_addr = $root_ppn << 12  # 一级页表的物理地址
  
  # SV39 虚拟地址拆分：VPN2(9位) + VPN1(9位) + VPN0(9位) + 页偏移(12位)
  set $vpn2 = ($vaddr >> 30) & 0x1FF  # 一级页表索引
  set $vpn1 = ($vaddr >> 21) & 0x1FF  # 二级页表索引
  set $vpn0 = ($vaddr >> 12) & 0x1FF  # 三级页表索引（最终 PTE）
  
  # 1. 读取一级页表项（L1 PTE）
  set $l1_pte_addr = $root_pte_addr + $vpn2 * 8  # PTE 占 8 字节
  printf "一级页表项地址: 0x%lx\n", $l1_pte_addr
  x/gx $l1_pte_addr  # 以 8 字节（64位）打印一级 PTE
  set $l1_pte = *(uint64_t*)$l1_pte_addr
  
  # 2. 读取二级页表项（L2 PTE）
  set $l2_ppn = ($l1_pte >> 10) & 0x00007FFFFFFFFFF  # 从 L1 PTE 提取二级页表 PPN
  set $l2_pte_addr = $l2_ppn << 12 + $vpn1 * 8
  printf "二级页表项地址: 0x%lx\n", $l2_pte_addr
  x/gx $l2_pte_addr
  set $l2_pte = *(uint64_t*)$l2_pte_addr
  
  # 3. 读取三级页表项（L3 PTE）→ 最终映射物理页的 PTE（含权限）
  set $l3_ppn = ($l2_pte >> 10) & 0x00007FFFFFFFFFF  # 从 L2 PTE 提取三级页表 PPN
  set $l3_pte_addr = $l3_ppn << 12 + $vpn0 * 8
  printf "三级页表项地址: 0x%lx\n", $l3_pte_addr
  x/gx $l3_pte_addr
  set $l3_pte = *(uint64_t*)$l3_pte_addr
  
  # 解析权限位（V/R/W/X）
  printf "虚拟地址 0x%lx 对应的 PTE 权限：\n", $vaddr
  printf "V(有效): %d, R(读): %d, W(写): %d, X(执行): %d\n",
         ($l3_pte & 1),        # V=bit0
         ($l3_pte & 2)>>1,     # R=bit1（右移1位取结果）
         ($l3_pte & 4)>>2,     # W=bit2（右移2位取结果）
         ($l3_pte & 8)>>3      # X=bit3（右移3位取结果）
end
find_pte 0xffffffe000200000
define find_pte
set $vaddr = $arg0
set $root_ppn = $satp & 0x00007FFFFFFFFFFF
set $root_pte_addr = $root_ppn << 12
set $vpn2 = ($vaddr >> 30) & 0x1FF
set $vpn1 = ($vaddr >> 21) & 0x1FF
set $vpn0 = ($vaddr >> 12) & 0x1FF
set $l1_pte_addr = $root_pte_addr + $vpn2 * 8
printf "一级页表项地址: 0x%lx\n", $l1_pte_addr
x/gx $l1_pte_addr
set $l1_pte = *(uint64_t*)$l1_pte_addr
set $l2_ppn = ($l1_pte >> 10) & 0x00007FFFFFFFFFF
set $l2_pte_addr = $l2_ppn << 12 + $vpn1 * 8
printf "二级页表项地址: 0x%lx\n", $l2_pte_addr
x/gx $l2_pte_addr
set $l2_pte = *(uint64_t*)$l2_pte_addr
set $l3_ppn = ($l2_pte >> 10) & 0x00007FFFFFFFFFF
set $l3_pte_addr = $l3_ppn << 12 + $vpn0 * 8
printf "三级页表项地址: 0x%lx\n", $l3_pte_addr
x/gx $l3_pte_addr
set $l3_pte = *(uint64_t*)$l3_pte_addr
printf "虚拟地址 0x%lx 对应的 PTE 权限：\n", $vaddr
printf "V(有效): %d, R(读): %d, W(写): %d, X(执行): %d\n",
($l3_pte & 1),
($l3_pte & 2)>>1,
($l3_pte & 4)>>2,
($l3_pte & 8)>>3
end
 find_pte 0xffffffe000200000
quit
targert remote:1234
target remote:1234
b test_rw
b main.c 26
b head.S:15
quit
target remote:1234
b head.S:19
b 0x80200018
b *0x80200018
c
quit
target remote:1234
info break
b head.S:16
b *8020000c
b *0x8020000c
c
s
si
s
si
s
si
s
si
si
si
si
si
si
si
si
si
s
si
si
si
si
si
b head.S:39
si
b head.S:39
c
b test_rw
c
info braek
info break
d b 1
d break 1
info break
c
si
s
s
s
s
s
s
s
s
s
finish
finish
n
n
quit
target remote:1234
b head.S:16
b *0x8020000c
c
n
si
n
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
li
ni
ni
ni
ni
ni
ni
ni
si
si
si
